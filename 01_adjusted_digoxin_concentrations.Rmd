---
title:     "Cirrincione T Study - Adjusting digoxin data and calculating summaries"
updated:   1/23/25
author:    Rene coig
output:    html_notebook
---
Study Description: The purpose of this project is to determine how testosterone affects other medications and the natural bacteria that lives in the gut.

Notebook Description: QC of digoxin plasma data, imputing concentrations for nominal timepoints using the ncappc package and calculating resulting summary data.

R version 4.4.2 "Pile of Leaves"

Load required packages.
```{r}
library(tidyverse)#data wrangling 
library(reshape2)#data wrangling
library(ncappc)#non-compartmental analysis
library(Publish)#ci.mean function
```
Load in Digoxin data
```{r}
rm(list = ls())#clearing environment
load("_output/data_dig_adjusted.RData")

data_dig_adjusted <- data_dig_adjusted%>%
  rename(ID=study_id)#ncappc package does not like the name "study_id"
```
Computing the non-compartmental pharmacokinetic analysis, with all timepoints included to generate lambda_zed. Lambda_zed will be used to adjust the drug concentration in the plasma for 24 and 48 hour ideal timepoints.
```{r}
ncappc(obsFile = data_dig_adjusted,
       str1Nm = "drug_visit_number_tru",
       str1 = c(1,2,3),
       concUnit = "ng/ml",
       timeUnit = "hours",
       doseUnit = "ng",
       idNmObs = "ID",
       timeNmObs = "time_hr_actual",
       concNmObs = "conc_1ml_adjust",
       doseAmtNm = "dose",
       onlyNCA = TRUE,
       LambdaTimeRange = "NULL",
       backExtrp = TRUE,
       method = "linearup-logdown",
       studyName = "T_Study",
       outFileNm = "T_STUDY",
       extrapolate = TRUE,
       gg_theme = theme_classic())

Lambda_zed <- ncaOutput %>% select(ID, drug_visit_number_tru, Lambda_z)
data_dig_adjusted<-merge(data_dig_adjusted,Lambda_zed,by=c("ID","drug_visit_number_tru"))
Lambda_zed
```
Use the lambda_z value to calculate imputed concentrations for nominal timepoints based on the observed time points using the equation: 
C = C(0) ∗ e^(−λ∗τ) where C(0) is the original concentration.

The 24 and 48 hour time points will be imputed for all individuals who have 24 and 48 hour data:
```{r}
# Impute the concentration values using the first-order kinetics equation for 24 and 48 hour concentrations, otherwise keeping the original concentrations
data_dig_adjusted <- data_dig_adjusted %>%
  mutate(
    conc_1ml_imp = ifelse(
      time_hr %in% c(24, 48),
      round(conc_1ml_adjust * exp(-Lambda_z * time_hr_actual), 3),
      conc_1ml_adjust
    )
  )

changed_rows <- data_dig_adjusted %>%
  mutate(
    value_changed = conc_1ml_imp != conc_1ml_adjust
  ) %>% filter(value_changed) %>% arrange(time_hr)
changed_rows#checking to ensure only 24 and 48 hours have changed
```
The 12 hour time points will be imputed only for 3 participants who had early sampling at the nominal 12 hour timepoint (due to UWMC TRU staffing limitations). These are: 
PID 7 Visit 3 (Note: this one is actually BLQ and will be unaffected anyway)
PID 18 Visit 1
PID 19 Visit 1 & 2
```{r}
# Update concentration values using the first-order kinetics equation for 12 hour values for select participant/drug visit combinations, otherwise keep the original concentration: 

# Specific participant and drug visit combinations that should be adjusted for 12 hours
condition <- (data_dig_adjusted$ID == 7 & data_dig_adjusted$drug_visit_number_tru == 3) |
             (data_dig_adjusted$ID == 18 & data_dig_adjusted$drug_visit_number_tru == 1) |
             (data_dig_adjusted$ID == 19 & data_dig_adjusted$drug_visit_number_tru == 1) |
             (data_dig_adjusted$ID == 19 & data_dig_adjusted$drug_visit_number_tru == 2)

# Impute the concentration values using the first-order kinetics equation for select 12-hour values, otherwise keeping the first set of imputed values
data_dig_adjusted <- data_dig_adjusted %>%
  mutate(
    conc_1ml_imp = ifelse(
      condition & time_hr %in% 12,
      round(conc_1ml_adjust * exp(-Lambda_z * time_hr_actual), 3),
      conc_1ml_imp
    )
  )

changed_rows <- data_dig_adjusted %>%
  mutate(
    value_changed = conc_1ml_imp != conc_1ml_adjust
  ) %>% filter(value_changed) %>% arrange(time_hr)
changed_rows#checking to ensure only the additional 12 hour timepoints were imputed
```
Re-run the ncappc package on the adjusted values to calculate new lambda_zed for nominal time points, for 0-24 hours.
```{r}
ncappc(obsFile = data_dig_adjusted,
       str1Nm = "drug_visit_number_tru",
       str1 = c(1,2,3),
       concUnit = "ng/ml",
       timeUnit = "hours",
       doseUnit = "ng",
       idNmObs = "ID",
       timeNmObs = "time_hr",
       concNmObs = "conc_1ml_imp",
       doseAmtNm = "dose",
       onlyNCA = TRUE,
       LambdaTimeRange = "NULL",
       method = "linearup-logdown",
       studyName = "T_Study",
       outFileNm = "T_STUDY",
       extrapolate = TRUE,
       gg_theme = theme_classic())

ncaOutput_0_last<-ncaOutput
Lambda_zed_new <- ncaOutput_0_last%>% select(ID, drug_visit_number_tru, Lambda_z)%>% rename(Lambda_z_new=Lambda_z)
data_dig_adjusted<-merge(data_dig_adjusted,Lambda_zed_new,by=c("ID","drug_visit_number_tru"))
plot(data_dig_adjusted$Lambda_z~data_dig_adjusted$Lambda_z_new) # lambda_z has been adjusted
```
Also run Non-compartmental analysis for 0-4 hours only to retrieve AUC.
```{r}
ncappc(obsFile = data_dig_adjusted%>%filter(time_hr<=4),
       str1Nm = "drug_visit_number_tru",
       str1 = c(1,2,3),
       concUnit = "ng/ml",
       timeUnit = "hours",
       doseUnit = "ng",
       idNmObs = "ID",
       timeNmObs = "time_hr",
       concNmObs = "conc_1ml_imp",
       doseAmtNm = "dose",
       onlyNCA = TRUE,
       LambdaTimeRange = "NULL",
       method = "linearup-logdown",
       studyName = "T_Study",
       outFileNm = "T_STUDY",
       extrapolate = TRUE,
       gg_theme = theme_classic())

ncaOutput_0_4<-ncaOutput
AUC_0_4 <- ncaOutput_0_4%>% select(ID, drug_visit_number_tru, AUClast)%>% rename(AUC4=AUClast)
ncaOutput<-merge(AUC_0_4,ncaOutput_0_last,by=c("ID","drug_visit_number_tru"))
```

Generate a new dataset with columns for mean concentration and standard deviation(SD).
```{r}
dig_summary <- data_dig_adjusted %>%
  group_by(time_hr, drug_visit_number_tru) %>%
  summarise(mean_conc = mean(conc_1ml_imp, na.rm = TRUE), 
            SD_conc = sd(conc_1ml_imp, na.rm = TRUE))
```
Create a new dataframe containing data for summary table (Cmax, AUClast, HL_lambda_z (terminal half-life), and Cl_obs). 
```{r}
PK_analysis <- ncaOutput %>% 
  select(ID, drug_visit_number_tru, Tmax, Cmax, Cl_obs, HL_Lambda_z, AUC4, AUClast) 
```
Reshape data from long format to wide format. 
```{r}
PK_analysis_wide <- dcast(melt(PK_analysis, id.vars=c("ID", "drug_visit_number_tru")), ID ~ variable+drug_visit_number_tru) 
```
Add a new column with ratios for 1 and 3 and 1 and 2 for geometric mean ratios.
```{r}
PK_analysis_wide$AUClast_ratio1_3 <- with(PK_analysis_wide, AUClast_3/AUClast_1) 
PK_analysis_wide$AUClast_ratio1_2 <- with(PK_analysis_wide, AUClast_2/AUClast_1) 

PK_analysis_wide$Cmax_ratio1_3 <- with(PK_analysis_wide, Cmax_3/Cmax_1) 
PK_analysis_wide$Cmax_ratio1_2 <- with(PK_analysis_wide, Cmax_2/Cmax_1) 

PK_analysis_wide$Cl_obs_ratio1_3 <- with(PK_analysis_wide, Cl_obs_3/Cl_obs_1) 
PK_analysis_wide$Cl_obs_ratio1_2 <- with(PK_analysis_wide, Cl_obs_2/Cl_obs_1) 

PK_analysis_wide$HL_Lambda_z_ratio1_3 <- with(PK_analysis_wide, HL_Lambda_z_3/HL_Lambda_z_1)
PK_analysis_wide$HL_Lambda_z_ratio1_2 <- with(PK_analysis_wide, HL_Lambda_z_2/HL_Lambda_z_1)
```
Calculate geometric mean ratios and 95% CI for the individual parameters.
```{r}
source("_source/geometric_mean.R")
AUC4_GMR1_3 <- "NA"
AUC4_GMR1_2 <- "NA"

AUC_GMR1_3 <- geo(PK_analysis_wide$AUClast_ratio1_3)
AUC_GMR1_2 <- geo(PK_analysis_wide$AUClast_ratio1_2)

Cmax_GMR1_3 <- geo(PK_analysis_wide$Cmax_ratio1_3)
Cmax_GMR1_2 <- geo(PK_analysis_wide$Cmax_ratio1_2)

Cl_GMR1_3 <- geo(PK_analysis_wide$Cl_obs_ratio1_3)
Cl_GMR1_2 <- geo(PK_analysis_wide$Cl_obs_ratio1_2)

HL_GMR1_3 <- geo(PK_analysis_wide$HL_Lambda_z_ratio1_3)
HL_GMR1_2 <- geo(PK_analysis_wide$HL_Lambda_z_ratio1_2)

Tmax_GMR1_3 <- "NA"
Tmax_GMR1_2 <- "NA"
results_GMR1_2 <- rbind(AUC4_GMR1_2, AUC_GMR1_2, Cmax_GMR1_2, HL_GMR1_2, Cl_GMR1_2, Tmax_GMR1_2)
results_GMR1_3 <- rbind(AUC4_GMR1_3, AUC_GMR1_3, Cmax_GMR1_3, HL_GMR1_3, Cl_GMR1_3, Tmax_GMR1_3)
```
Calculate geometric means and 95% CI for the individual parameters.
```{r}
source("_source/geometric_mean.R")

AUC_1_geo <- geo(PK_analysis_wide$AUClast_1)
AUC_2_geo <- geo(PK_analysis_wide$AUClast_2)
AUC_3_geo <- geo(PK_analysis_wide$AUClast_3)

AUC4_1_geo <- geo(PK_analysis_wide$AUC4_1)
AUC4_2_geo <- geo(PK_analysis_wide$AUC4_2)
AUC4_3_geo <- geo(PK_analysis_wide$AUC4_3)

Cmax_1_geo <- geo(PK_analysis_wide$Cmax_1)
Cmax_2_geo <- geo(PK_analysis_wide$Cmax_2)
Cmax_3_geo <- geo(PK_analysis_wide$Cmax_3)

Cl_1_geo <- geo(PK_analysis_wide$Cl_obs_1)
Cl_2_geo <- geo(PK_analysis_wide$Cl_obs_2)
Cl_3_geo <- geo(PK_analysis_wide$Cl_obs_3)

HL_1_geo <- geo(PK_analysis_wide$HL_Lambda_z_1)
HL_2_geo <- geo(PK_analysis_wide$HL_Lambda_z_2)
HL_3_geo <- geo(PK_analysis_wide$HL_Lambda_z_3)

Tmax_1_geo <- geo(PK_analysis_wide$Tmax_1)
Tmax_2_geo <- geo(PK_analysis_wide$Tmax_2)
Tmax_3_geo <- geo(PK_analysis_wide$Tmax_3)

results_geo_1 <- rbind(AUC4_1_geo, AUC_1_geo, Cmax_1_geo, Cl_1_geo, HL_1_geo, Tmax_1_geo)
results_geo_2 <- rbind(AUC4_2_geo, AUC_2_geo, Cmax_2_geo, Cl_2_geo, HL_2_geo, Tmax_2_geo)
results_geo_3 <- rbind(AUC4_3_geo, AUC_3_geo, Cmax_3_geo, Cl_3_geo, HL_3_geo, Tmax_3_geo)
```
Calculate arithmetic mean and standard deviation for the individual parameters.
```{r}
source("_source/arithmetic_mean.R")
AUC_1_Mean <- arithmean(PK_analysis_wide$AUClast_1)
AUC_2_Mean <- arithmean(PK_analysis_wide$AUClast_2)
AUC_3_Mean <- arithmean(PK_analysis_wide$AUClast_3)

AUC4_1_Mean <- arithmean(PK_analysis_wide$AUC4_1)
AUC4_2_Mean <- arithmean(PK_analysis_wide$AUC4_2)
AUC4_3_Mean <- arithmean(PK_analysis_wide$AUC4_3)

Cmax_1_Mean <- arithmean(PK_analysis_wide$Cmax_1)
Cmax_2_Mean <- arithmean(PK_analysis_wide$Cmax_2)
Cmax_3_Mean <- arithmean(PK_analysis_wide$Cmax_3)

Cl_1_Mean <- arithmean(PK_analysis_wide$Cl_obs_1)
Cl_2_Mean <- arithmean(PK_analysis_wide$Cl_obs_2)
Cl_3_Mean <- arithmean(PK_analysis_wide$Cl_obs_3)

HL_1_Mean <- arithmean(PK_analysis_wide$HL_Lambda_z_1)
HL_2_Mean <- arithmean(PK_analysis_wide$HL_Lambda_z_2)
HL_3_Mean <- arithmean(PK_analysis_wide$HL_Lambda_z_3)


Tmax_1_Mean <- arithmean(PK_analysis_wide$Tmax_1)
Tmax_2_Mean <- arithmean(PK_analysis_wide$Tmax_2)
Tmax_3_Mean <- arithmean(PK_analysis_wide$Tmax_3)

results_Mean_1 <- rbind(AUC4_1_Mean, AUC_1_Mean, Cmax_1_Mean, Cl_1_Mean, HL_1_Mean, Tmax_1_Mean)
results_Mean_2 <- rbind(AUC4_2_Mean, AUC_2_Mean, Cmax_2_Mean, Cl_2_Mean, HL_2_Mean, Tmax_2_Mean)
results_Mean_3 <- rbind(AUC4_3_Mean, AUC_3_Mean, Cmax_3_Mean, Cl_3_Mean, HL_3_Mean, Tmax_3_Mean)
```
Calculate median for the individual parameters pre and post T. Filter out the individuals that have NA values.
```{r}
source("_source/medians.R")

AUC_1_M <- medians(PK_analysis_wide$AUClast_1)
AUC_2_M <- medians(PK_analysis_wide$AUClast_2)
AUC_3_M <- medians(PK_analysis_wide$AUClast_3)

AUC4_1_M <- medians(PK_analysis_wide$AUC4_1)
AUC4_2_M <- medians(PK_analysis_wide$AUC4_2)
AUC4_3_M <- medians(PK_analysis_wide$AUC4_3)

Cmax_1_M <- medians(PK_analysis_wide$Cmax_1)
Cmax_2_M <- medians(PK_analysis_wide$Cmax_2)
Cmax_3_M <- medians(PK_analysis_wide$Cmax_3)

Cl_1_M <- medians(PK_analysis_wide$Cl_obs_1)
Cl_2_M <- medians(PK_analysis_wide$Cl_obs_2)
Cl_3_M <- medians(PK_analysis_wide$Cl_obs_3)

HL_1_M <- medians(PK_analysis_wide$HL_Lambda_z_1)
HL_2_M <- medians(PK_analysis_wide$HL_Lambda_z_2)
HL_3_M <- medians(PK_analysis_wide$HL_Lambda_z_3)

Tmax_1_M <- medians(PK_analysis_wide$Tmax_1)
Tmax_2_M <- medians(PK_analysis_wide$Tmax_2)
Tmax_3_M <- medians(PK_analysis_wide$Tmax_3)

results_median1 <- rbind(AUC4_1_M, AUC_1_M, Cmax_1_M, HL_1_M, Cl_1_M, Tmax_1_M) 
results_median2 <- rbind(AUC4_2_M, AUC_2_M, Cmax_2_M, HL_2_M, Cl_2_M, Tmax_2_M) 
results_median3 <- rbind(AUC4_3_M, AUC_3_M, Cmax_3_M, HL_3_M, Cl_3_M, Tmax_3_M) 
```
Assemble a table with all of these metrics in one wide format
```{r}
Table2 <- matrix(nrow=6, ncol=0)
Table2 <- cbind(results_median1, results_geo_1, results_Mean_1,
                results_median2, results_geo_2, results_Mean_2,
                results_median3, results_geo_3, results_Mean_3,
                results_GMR1_2, results_GMR1_3, Table2)

colnames1 <- c("PRE T (Median (IQR))", "PRE T (Geo Mean (95% CI))",  "PRE T (Mean (SD))", 
               "4 weeks POST T (Median (IQR))", "4 weeks POST T (Geo Mean (95% CI))", "4 weeks POST T (Mean (SD))",
               "12 weeks POST T (Median (IQR))", "12 weeks POST T Geo Mean (95% CI))", "12 weeks POST T (Mean (SD))",
               "GMR 4 weeks (95% CI)", "GMR 12 weeks (95% CI)")
Table2 <- rbind(colnames1, Table2)
rownames1 <- c("DRUG", "Digoxin", "", "", "", "", "")
rownames2 <- c("PARAMETER", "AUC 0-4 (ng*hr)/ml", "AUC 0-last (ng*hr)/ml", "Cmax (ng/ml)", "T1/2 (hrs)", "CL/F (mL/hr)", "Tmax (hrs)")
Table2 <- cbind(rownames1, rownames2, Table2)
```
Save out final adjusted Digoxin data and NCA output in R format for plots and statistical analysis.
```{r}
write.table(Table2, file = "_output/NCAPPC_summary.csv", row.names = FALSE, col.names=FALSE, sep = ",")
write.csv(ncaOutput, file = "_output/NCAPPC_output.csv", row.names = FALSE)
save(ncaOutput,data_dig_adjusted,dig_summary,PK_analysis, PK_analysis_wide, file = "_output/NCA_analysis.RData")
```